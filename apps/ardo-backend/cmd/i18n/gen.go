package main

import (
	"bytes"
	"encoding/csv"
	"errors"
	"flag"
	"fmt"
	"go/format"
	"log"
	"os"
	"strings"
)

var (
	csvPath = flag.String("csv", "", "path to csv file")
	outPath = flag.String("out", "", "file path to output generated code")
	pkgName = flag.String("pkg", "", "name of generated file's package")
)

func dieIf(err error) {
	if err != nil {
		log.Fatal(err)
	}
}

type txtRow struct {
	Key  string
	Vals []string
}

func main() {
	fmt.Println("Generate resource file")

	flag.Parse()
	if csvPath == nil || outPath == nil || pkgName == nil {
		dieIf(errors.New("must pass all args: --csv, --out, --pkg"))
		return
	}

	f, err := os.Open(*csvPath)
	dieIf(err)
	defer f.Close()

	lines, err := csv.NewReader(f).ReadAll()
	dieIf(err)

	// read header
	header := lines[0]
	langs := make([]string, len(header)-1)
	for i, h := range header[1:] {
		langs[i] = h
	}

	keysMap := make(map[string]bool)
	rows := make([]txtRow, len(lines)-1)

	// read rows
	for i, line := range lines[1:] {
		key := line[0]

		// error if key already present
		if _, ok := keysMap[key]; ok {
			dieIf(fmt.Errorf("duplicate key \"%s\" on line %v", key, i+1))
			return
		}

		row := txtRow{
			Key:  key,
			Vals: make([]string, len(langs)),
		}
		for j, v := range line[1:] {
			row.Vals[j] = v
		}
		rows[i] = row
	}

	var buf bytes.Buffer

	// prepare strings
	var (
		sConsts string
		sMap    string
		sCases  string
	)

	// foreach row
	for i, row := range rows {
		txtKey := fmt.Sprintf("TXT_%s", strings.ReplaceAll(strings.ToUpper(row.Key), "-", "_"))
		sConsts += fmt.Sprintf("%s TxtKey = %v\n", txtKey, i+1)
		sCases += fmt.Sprintf("case %s:\n\treturn \"%s\"\n", txtKey, row.Key)
		var sVals string
		for i, lang := range langs {
			sVals += fmt.Sprintf("%s: `%s`,\n", lang, row.Vals[i])
		}
		sMap += fmt.Sprintf("%s: MlString{\n%s},\n", txtKey, sVals)
	}

	_, err = buf.WriteString(fmt.Sprintf(`
// code generated by gen.go
// DO NOT EDIT.
package %s

const (
	%s
)

var Txts = TxtResource{
	%s
}

func GetTxtKeyAsString(k TxtKey) string {
	switch k {
	%s
	default: return ""
	}
}`, *pkgName, sConsts, sMap, sCases))

	fmtBs, err := format.Source(buf.Bytes())
	if err != nil {
		fmt.Println(string(buf.Bytes()))
		fmt.Println(err)
		return
	}

	fw, err := os.Create(*outPath)
	dieIf(err)
	defer fw.Close()

	_, err = fw.Write(fmtBs)
	dieIf(err)

	fmt.Printf("done generating to %s\n", *outPath)
}
